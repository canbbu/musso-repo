# Supabase 통합 계획

## 현재 데이터 구조에서 Supabase로의 마이그레이션 계획

### 1. 테이블 구조 설계

현재 프로젝트의 타입스크립트 인터페이스를 기반으로 다음과 같은 Supabase 테이블 구조를 구현할 수 있습니다:

```sql
-- Players 테이블
CREATE TABLE players (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- players 테이블에 회원 관리에 필요한 필드 추가
ALTER TABLE players 
ADD COLUMN username VARCHAR(255),
ADD COLUMN password VARCHAR(255),
ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE;

-- Announcements 테이블
CREATE TABLE announcements (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('notice', 'match')),
  content TEXT NOT NULL,
  date DATE NOT NULL,
  author TEXT NOT NULL,
  location TEXT,
  opponent TEXT,
  match_time TIMESTAMP,
  attendance_tracking BOOLEAN,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Matches 테이블
CREATE TABLE matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL,
  location TEXT NOT NULL,
  opponent TEXT,
  status TEXT DEFAULT 'scheduled' CHECK (status IN ('scheduled', 'cancelled', 'completed')),
  score TEXT,
  result TEXT CHECK (result IN ('win', 'loss', 'draw', null)),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Match_Attendance 테이블
CREATE TABLE match_attendance (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  match_id BIGINT REFERENCES matches(id) ON DELETE CASCADE,
  player_id UUID REFERENCES players(id) ON DELETE CASCADE,
  status TEXT NOT NULL CHECK (status IN ('attending', 'not_attending', 'pending')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(match_id, player_id)
);

-- Transactions 테이블
CREATE TABLE transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL,
  description TEXT NOT NULL,
  amount DECIMAL(10, 2) NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('income', 'expense')),
  category TEXT NOT NULL,
  member TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Member_Dues 테이블
CREATE TABLE member_dues (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  player_id UUID REFERENCES players(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  paid BOOLEAN NOT NULL DEFAULT false,
  due_date DATE NOT NULL,
  amount DECIMAL(10, 2) NOT NULL,
  paid_date DATE,
  paid_amount DECIMAL(10, 2),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Mvp_Votes 테이블 (MVP 투표 기능 위한 테이블)
CREATE TABLE mvp_votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  match_id BIGINT REFERENCES matches(id) ON DELETE CASCADE,
  voter_id UUID REFERENCES players(id) ON DELETE CASCADE,
  voted_for_id UUID REFERENCES players(id) ON DELETE CASCADE,
  reason TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(match_id, voter_id)
);
```

-- 테이블에 role 필드가 없는 경우 추가
ALTER TABLE players 
ADD COLUMN IF NOT EXISTS role VARCHAR(50) DEFAULT 'player';

-- 한글 역할명을 영문 코드로 매핑하는 참조 테이블 생성
CREATE TABLE IF NOT EXISTS player_roles (
  role_code VARCHAR(50) PRIMARY KEY,
  role_name VARCHAR(50) NOT NULL,
  description TEXT
);

-- 역할 데이터 삽입
INSERT INTO player_roles (role_code, role_name, description)
VALUES 
  ('president', '회장', '공지사항 관리, 회원 관리 권한'),
  ('vice_president', '부회장', '공지사항 관리, 회원 관리 권한'),
  ('coach', '감독', '경기 관리, 기록 관리 권한'),
  ('assistant_coach', '코치', '경기 관리, 기록 관리 권한'),
  ('treasurer', '회계', '재정 관리 권한'),
  ('player', '일반회원', '기본 권한')
ON CONFLICT (role_code) DO UPDATE 
SET role_name = EXCLUDED.role_name,
    description = EXCLUDED.description;

### 2. 데이터 접근 레이어 구현

현재 모의 데이터를 사용하는 훅들을 Supabase 통합 훅으로 변경해야 합니다:

#### `useAnnouncements` 훅 변경 예시:

```typescript
import { useState, useEffect } from 'react';
import { Announcement } from '@/types/dashboard';
import { supabase } from '@/lib/supabase';

export function useAnnouncements() {
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchAnnouncements() {
      try {
        setLoading(true);
        const { data, error } = await supabase
          .from('announcements')
          .select('*')
          .order('date', { ascending: false });

        if (error) throw error;
        
        setAnnouncements(data || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다');
      } finally {
        setLoading(false);
      }
    }

    fetchAnnouncements();
  }, []);

  const addAnnouncement = async (newAnnouncement: Omit<Announcement, 'id'>) => {
    try {
      const { data, error } = await supabase
        .from('announcements')
        .insert(newAnnouncement)
        .select()
        .single();
      
      if (error) throw error;
      
      setAnnouncements(prev => [data, ...prev]);
      return data;
    } catch (err) {
      setError(err instanceof Error ? err.message : '공지사항 추가 중 오류가 발생했습니다');
      throw err;
    }
  };

  const updateAnnouncement = async (id: number, updates: Partial<Announcement>) => {
    try {
      const { data, error } = await supabase
        .from('announcements')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      
      setAnnouncements(prev => 
        prev.map(item => item.id === id ? data : item)
      );
      return data;
    } catch (err) {
      setError(err instanceof Error ? err.message : '공지사항 업데이트 중 오류가 발생했습니다');
      throw err;
    }
  };

  const deleteAnnouncement = async (id: number) => {
    try {
      const { error } = await supabase
        .from('announcements')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
      
      setAnnouncements(prev => prev.filter(item => item.id !== id));
    } catch (err) {
      setError(err instanceof Error ? err.message : '공지사항 삭제 중 오류가 발생했습니다');
      throw err;
    }
  };

  return { 
    announcements, 
    loading, 
    error,
    addAnnouncement,
    updateAnnouncement,
    deleteAnnouncement
  };
}
```

### 3. 실시간 업데이트 구현

참석 여부나 MVP 투표 같은 기능에는 실시간 업데이트가 필요할 수 있습니다:

```typescript
import { useState, useEffect } from 'react';
import { UpcomingMatch } from '@/types/dashboard';
import { supabase } from '@/lib/supabase';

export function useUpcomingMatches() {
  const [upcomingMatches, setUpcomingMatches] = useState<UpcomingMatch[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchMatches() {
      try {
        setLoading(true);
        
        // 기본 매치 데이터 가져오기
        const { data: matchesData, error: matchesError } = await supabase
          .from('matches')
          .select(`
            id,
            date,
            location,
            opponent,
            status
          `)
          .gte('date', new Date().toISOString().split('T')[0])
          .order('date');

        if (matchesError) throw matchesError;
        
        // 각 매치에 대한 참석 상태 계산을 위한 추가 쿼리
        const matchesWithAttendance = await Promise.all(
          (matchesData || []).map(async (match) => {
            const { data: attendanceData, error: attendanceError } = await supabase
              .from('match_attendance')
              .select(`
                status,
                players:player_id(id, name)
              `)
              .eq('match_id', match.id);
              
            if (attendanceError) throw attendanceError;
            
            // 참석 상태별 집계
            const attending = attendanceData?.filter(a => a.status === 'attending').length || 0;
            const notAttending = attendanceData?.filter(a => a.status === 'not_attending').length || 0;
            const pending = attendanceData?.filter(a => a.status === 'pending').length || 0;
            
            // 참석 상태별 플레이어 목록
            const attendingPlayers = attendanceData
              ?.filter(a => a.status === 'attending')
              .map(a => a.players) || [];
              
            const notAttendingPlayers = attendanceData
              ?.filter(a => a.status === 'not_attending')
              .map(a => a.players) || [];
              
            const pendingPlayers = attendanceData
              ?.filter(a => a.status === 'pending')
              .map(a => a.players) || [];
            
            return {
              ...match,
              attending,
              notAttending,
              pending,
              attendingPlayers,
              notAttendingPlayers,
              pendingPlayers
            };
          })
        );
        
        setUpcomingMatches(matchesWithAttendance);
      } catch (err) {
        setError(err instanceof Error ? err.message : '경기 정보를 불러오는 중 오류가 발생했습니다');
      } finally {
        setLoading(false);
      }
    }

    fetchMatches();
    
    // 실시간 구독 설정
    const matchesSubscription = supabase
      .channel('public:matches')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'matches' }, 
        () => { fetchMatches(); }
      )
      .subscribe();
      
    const attendanceSubscription = supabase
      .channel('public:match_attendance')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'match_attendance' }, 
        () => { fetchMatches(); }
      )
      .subscribe();
    
    return () => {
      supabase.removeChannel(matchesSubscription);
      supabase.removeChannel(attendanceSubscription);
    };
  }, []);

  // 참석 상태 변경 함수
  const updateAttendance = async (matchId: number, playerId: string, status: 'attending' | 'not_attending' | 'pending') => {
    try {
      const { data: existing, error: checkError } = await supabase
        .from('match_attendance')
        .select()
        .eq('match_id', matchId)
        .eq('player_id', playerId)
        .maybeSingle();
        
      if (checkError) throw checkError;
      
      if (existing) {
        // 기존 참석 상태 업데이트
        const { error: updateError } = await supabase
          .from('match_attendance')
          .update({ status })
          .eq('match_id', matchId)
          .eq('player_id', playerId);
          
        if (updateError) throw updateError;
      } else {
        // 새 참석 상태 생성
        const { error: insertError } = await supabase
          .from('match_attendance')
          .insert({
            match_id: matchId,
            player_id: playerId,
            status
          });
          
        if (insertError) throw insertError;
      }
      
      // 실시간 업데이트로 인해 상태가 자동으로 갱신됨
    } catch (err) {
      setError(err instanceof Error ? err.message : '참석 상태를 업데이트하는 중 오류가 발생했습니다');
      throw err;
    }
  };

  return { 
    upcomingMatches, 
    loading, 
    error,
    updateAttendance 
  };
}
```

### 4. 인증 및 권한 관리

Supabase Auth와 Row-Level Security (RLS) 정책을 활용하여 데이터 접근 권한을 관리할 수 있습니다:

```sql
-- 예: Announcements 테이블에 대한 RLS 정책
-- 관리자만 추가/수정/삭제 가능, 모든 사용자는 읽기 가능
ALTER TABLE announcements ENABLE ROW LEVEL SECURITY;

CREATE POLICY "모든 사용자가 공지사항을 볼 수 있음" 
ON announcements FOR SELECT USING (true);

CREATE POLICY "관리자만 공지사항을 추가할 수 있음" 
ON announcements FOR INSERT 
WITH CHECK (auth.jwt() ->> 'role' = 'admin');

CREATE POLICY "관리자만 공지사항을 업데이트할 수 있음" 
ON announcements FOR UPDATE 
USING (auth.jwt() ->> 'role' = 'admin');

CREATE POLICY "관리자만 공지사항을 삭제할 수 있음" 
ON announcements FOR DELETE 
USING (auth.jwt() ->> 'role' = 'admin');

-- 예: Match_Attendance 테이블에 대한 RLS 정책
-- 사용자는 자신의 참석 상태만 변경 가능
ALTER TABLE match_attendance ENABLE ROW LEVEL SECURITY;

CREATE POLICY "모든 사용자가 참석 상태를 볼 수 있음" 
ON match_attendance FOR SELECT USING (true);

CREATE POLICY "사용자는 자신의 참석 상태만 추가할 수 있음" 
ON match_attendance FOR INSERT 
WITH CHECK (auth.uid() = player_id);

CREATE POLICY "사용자는 자신의 참석 상태만 업데이트할 수 있음" 
ON match_attendance FOR UPDATE 
USING (auth.uid() = player_id);
```

## 마이그레이션 단계별 계획

1. **Supabase 프로젝트 생성 및 설정**
   - 새 Supabase 프로젝트 생성
   - 테이블 스키마 생성
   - RLS 정책 설정
   - 인증 설정 (OAuth, 이메일 등)

2. **클라이언트 연결 설정**
   - Supabase 클라이언트 설정
   - 인증 관련 훅 및 컨텍스트 설정

3. **데이터 접근 레이어 구현**
   - 각 모형 데이터 훅을 Supabase 훅으로 변경
   - CRUD 연산 구현
   - 실시간 구독 설정

4. **테스트 및 디버깅**
   - 각 데이터 접근 기능 테스트
   - 실시간 업데이트 테스트
   - 인증 및 권한 테스트

5. **프로덕션 배포**
   - 최종 확인 및 배포
   - 모니터링 설정

## 기술적 고려사항

1. **성능 최적화**
   - 복잡한 쿼리는 PostgreSQL 함수 또는 뷰로 작성 고려
   - 캐싱 전략 구현 (React-Query 등)

2. **보안**
   - RLS 정책 철저한 검증
   - API 엔드포인트 보안 검토
   - 민감한 데이터 암호화 고려

3. **확장성**
   - 데이터 성장에 따른 쿼리 최적화 계획
   - 인덱싱 전략
   - 백업 및 복구 전략 